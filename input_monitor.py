"""
Input Monitor Module for Autolauncher.
Detects REAL keyboard/mouse input vs simulated/injected input.

Uses low-level Windows hooks to check the INJECTED flag on input events,
filtering out input generated by automation programs (SendInput, AutoHotkey, etc).
"""

import time
import threading
import ctypes
from ctypes import wintypes
from typing import Optional

from logger import get_logger

logger = get_logger(__name__)


# Windows API Constants for Low-Level Hooks
WH_KEYBOARD_LL = 13
WH_MOUSE_LL = 14
WM_KEYDOWN = 0x0100
WM_KEYUP = 0x0101
WM_SYSKEYDOWN = 0x0104
WM_SYSKEYUP = 0x0105
WM_MOUSEMOVE = 0x0200
WM_LBUTTONDOWN = 0x0201
WM_LBUTTONUP = 0x0202
WM_RBUTTONDOWN = 0x0204
WM_RBUTTONUP = 0x0205
WM_MBUTTONDOWN = 0x0207
WM_MBUTTONUP = 0x0208
WM_MOUSEWHEEL = 0x020A

# INJECTED flags
LLKHF_INJECTED = 0x00000010  # Keyboard: event was injected
LLMHF_INJECTED = 0x00000001  # Mouse: event was injected


class KBDLLHOOKSTRUCT(ctypes.Structure):
    """Low-level keyboard hook structure."""
    _fields_ = [
        ('vkCode', wintypes.DWORD),
        ('scanCode', wintypes.DWORD),
        ('flags', wintypes.DWORD),
        ('time', wintypes.DWORD),
        ('dwExtraInfo', ctypes.POINTER(ctypes.c_ulong)),
    ]


class MSLLHOOKSTRUCT(ctypes.Structure):
    """Low-level mouse hook structure."""
    _fields_ = [
        ('pt', wintypes.POINT),
        ('mouseData', wintypes.DWORD),
        ('flags', wintypes.DWORD),
        ('time', wintypes.DWORD),
        ('dwExtraInfo', ctypes.POINTER(ctypes.c_ulong)),
    ]


# Type for hook callback
HOOKPROC = ctypes.WINFUNCTYPE(ctypes.c_long, ctypes.c_int, wintypes.WPARAM, wintypes.LPARAM)


class InputMonitor:
    """
    Monitors for REAL (non-simulated) keyboard and mouse input.
    
    Uses Windows low-level hooks to detect the INJECTED flag, which is set
    when input is generated by programs like AutoHotkey, game macros, etc.
    Only tracks input that comes from actual hardware.
    """
    
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        """Singleton pattern to ensure only one monitor runs."""
        with cls._lock:
            if cls._instance is None:
                cls._instance = super().__new__(cls)
                cls._instance._initialized = False
            return cls._instance
    
    def __init__(self):
        if self._initialized:
            return
        
        # Initialize to epoch (0) so if no real input detected, system is considered idle
        # This prevents false "user active" when user is actually AFK
        self._last_real_input = 0.0
        self._has_detected_input = False  # Track if any real input has been seen
        self._running = False
        self._thread: Optional[threading.Thread] = None
        self._keyboard_hook = None
        self._mouse_hook = None
        
        # Keep references to callbacks to prevent GC
        self._keyboard_callback = None
        self._mouse_callback = None
        
        # Load user32.dll
        self._user32 = ctypes.windll.user32
        self._kernel32 = ctypes.windll.kernel32
        
        self._initialized = True
        
        # Define 64-bit compatible argtypes
        # HHOOK is a handle (pointer), so on 64-bit it's 64-bit.
        # ctypes default is c_int (32-bit), causing OverflowError.
        HHOOK = wintypes.HHOOK if hasattr(wintypes, 'HHOOK') else wintypes.HANDLE
        LRESULT = wintypes.LRESULT if hasattr(wintypes, 'LRESULT') else ctypes.c_long
        
        self._user32.CallNextHookEx.argtypes = [HHOOK, ctypes.c_int, wintypes.WPARAM, wintypes.LPARAM]
        self._user32.CallNextHookEx.restype = LRESULT
        
        self._user32.SetWindowsHookExW.argtypes = [ctypes.c_int, HOOKPROC, wintypes.HINSTANCE, wintypes.DWORD]
        self._user32.SetWindowsHookExW.restype = HHOOK
        
        self._user32.UnhookWindowsHookEx.argtypes = [HHOOK]
        self._user32.UnhookWindowsHookEx.restype = wintypes.BOOL
        
        logger.info("InputMonitor initialized")
    
    def _keyboard_hook_callback(self, nCode: int, wParam: int, lParam: int) -> int:
        """Low-level keyboard hook callback."""
        if nCode >= 0:
            kb_struct = ctypes.cast(lParam, ctypes.POINTER(KBDLLHOOKSTRUCT)).contents
            
            # Check if this is a key press (not release) and NOT injected
            if wParam in (WM_KEYDOWN, WM_SYSKEYDOWN):
                is_injected = bool(kb_struct.flags & LLKHF_INJECTED)
                
                if not is_injected:
                    self._last_real_input = time.time()
                    self._has_detected_input = True
                    # Logging removed for performance in critical hook path
        
        # Call next hook
        return self._user32.CallNextHookEx(self._keyboard_hook, nCode, wParam, lParam)
    
    def _mouse_hook_callback(self, nCode: int, wParam: int, lParam: int) -> int:
        """Low-level mouse hook callback."""
        if nCode >= 0:
            mouse_struct = ctypes.cast(lParam, ctypes.POINTER(MSLLHOOKSTRUCT)).contents
            
            # Check for mouse button or movement and NOT injected
            # Skip pure mouse moves to reduce noise (only track clicks and wheel)
            if wParam in (WM_LBUTTONDOWN, WM_RBUTTONDOWN, WM_MBUTTONDOWN, WM_MOUSEWHEEL):
                is_injected = bool(mouse_struct.flags & LLMHF_INJECTED)
                
                if not is_injected:
                    self._last_real_input = time.time()
                    self._has_detected_input = True
                    # Logging removed for performance in critical hook path
        
        # Call next hook
        return self._user32.CallNextHookEx(self._mouse_hook, nCode, wParam, lParam)
    
    def _hook_thread(self):
        """Background thread that runs the message loop for hooks."""
        logger.info("InputMonitor hook thread starting...")
        
        try:
            # Create callbacks (must keep references!)
            self._keyboard_callback = HOOKPROC(self._keyboard_hook_callback)
            self._mouse_callback = HOOKPROC(self._mouse_hook_callback)
            
            # Set keyboard hook
            self._keyboard_hook = self._user32.SetWindowsHookExW(
                WH_KEYBOARD_LL,
                self._keyboard_callback,
                None,
                0
            )
            
            if not self._keyboard_hook:
                logger.error(f"Failed to set keyboard hook: {ctypes.get_last_error()}")
            else:
                logger.info("Keyboard hook installed successfully")
            
            # Set mouse hook
            # DISABLED: Mouse hooks in Python are too slow for high-polling rate mice (1000Hz+)
            # causing system-wide input lag/freeze, especially when UI is active (GIL contention).
            self._mouse_hook = None
            """
            self._mouse_hook = self._user32.SetWindowsHookExW(
                WH_MOUSE_LL,
                self._mouse_callback,
                None,
                0
            )
            
            if not self._mouse_hook:
                logger.error(f"Failed to set mouse hook: {ctypes.get_last_error()}")
            else:
                logger.info("Mouse hook installed successfully")
            """
            
            # Message loop - required for low-level hooks to work
            msg = wintypes.MSG()
            while self._running:
                # Use PeekMessage with a short timeout to allow clean shutdown
                if self._user32.PeekMessageW(ctypes.byref(msg), None, 0, 0, 1):  # PM_REMOVE = 1
                    self._user32.TranslateMessage(ctypes.byref(msg))
                    self._user32.DispatchMessageW(ctypes.byref(msg))
                else:
                    # No messages, sleep briefly to reduce CPU usage
                    time.sleep(0.01)
                
        except Exception as e:
            logger.error(f"InputMonitor hook thread error: {e}")
        finally:
            self._cleanup_hooks()
            logger.info("InputMonitor hook thread stopped")
    
    def _cleanup_hooks(self):
        """Remove installed hooks."""
        if self._keyboard_hook:
            self._user32.UnhookWindowsHookEx(self._keyboard_hook)
            self._keyboard_hook = None
            
        if self._mouse_hook:
            self._user32.UnhookWindowsHookEx(self._mouse_hook)
            self._mouse_hook = None
    
    def start(self):
        """Start monitoring for real input."""
        if self._running:
            return
            
        self._running = True
        # Do NOT reset _last_real_input here - we want to detect if user is truly idle
        # If no real input has been detected yet, the system remains in "idle" state
        self._thread = threading.Thread(target=self._hook_thread, daemon=True)
        self._thread.start()
        logger.info("InputMonitor started")
    
    def stop(self):
        """Stop monitoring."""
        if not self._running:
            return
            
        self._running = False
        if self._thread:
            self._thread.join(timeout=2)
        logger.info("InputMonitor stopped")
    
    def get_real_idle_time(self) -> float:
        """
        Get the time in seconds since the last REAL (non-injected) input.
        
        Returns:
            float: Seconds since last real keyboard/mouse input
        """
        return time.time() - self._last_real_input
    
    def wait_for_idle(self, duration: float, check_interval: float = 5.0) -> bool:
        """
        Monitor for real input over a duration.
        
        Args:
            duration: How long to monitor (in seconds)
            check_interval: How often to check for input (in seconds)
            
        Returns:
            True if user was TRULY idle (no real input detected during monitoring)
            False if real input was detected
        """
        logger.info(f"Monitoring for real input for {duration:.0f} seconds...")
        
        start_time = time.time()
        self._last_real_input = start_time  # Reset at start of monitoring
        
        while time.time() - start_time < duration:
            time.sleep(check_interval)
            real_idle = self.get_real_idle_time()
            
            # If there was real input since we started monitoring
            if real_idle < (time.time() - start_time):
                logger.info(f"Real input detected during monitoring (idle: {real_idle:.1f}s)")
                return False
        
        logger.info(f"No real input detected for {duration:.0f} seconds")
        return True


# Global singleton instance
_input_monitor: Optional[InputMonitor] = None


def get_input_monitor() -> InputMonitor:
    """Get the global InputMonitor instance."""
    global _input_monitor
    if _input_monitor is None:
        _input_monitor = InputMonitor()
    return _input_monitor


def start_input_monitor():
    """Start the global input monitor."""
    monitor = get_input_monitor()
    monitor.start()


def stop_input_monitor():
    """Stop the global input monitor."""
    if _input_monitor:
        _input_monitor.stop()
